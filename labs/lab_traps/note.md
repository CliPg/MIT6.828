# lecture
我们每次调用一个函数，函数都会为自己创建一个Stack Frame供自己使用。函数通过移动Stack Point来完成Stack Frame的空间分配。

Stack是从高地址向低地址使用的，每个Stack Frame包含寄存器和本地变量。其中**Return Address**总是出现在Stack Frame的第一位，紧随的是指向前一个Stack Frame的指针。

Stack Frame有两个重要的寄存器，一个是SP(Stack Pointer)，指向Stack Frame的底部；一个是FP(Frame Pointer)，指向其顶部。因此，通过读取FP寄存器的值，可以知道当前Stack Frame的顶部地址，也可以进一步计算当前Stack Frame指向前一个Stack Frame的指针的地址，从而知道前一个Stack Frame的顶部地址。保存前一个Stack Frame的指针可以方便我们跳转回去。

每当程序执行系统调用、程序出现了类似page fault、运算时除以0的错误、一个设备触发了中断使得当前程序运行需要响应内核设备驱动，程序都会完成用户空间和内核空间的切换。这样的切换称为**trap**。

从只拥有user权限并且位于用户空间的Shell，切换到拥有supervisor权限的内核，在这个过程中，硬件的状态将会非常重要，因为我们很多的工作都是将硬件从适合运行用户应用程序的状态，改变到适合运行内核代码的状态。

一些需要了解的寄存器：

- 堆栈寄存器（Stack Register）。

- 在硬件中还有一个寄存器叫做程序计数器（Program Counter Register）。
- 表明当前mode的标志位，这个标志位表明了当前是supervisor mode还是user mode。当我们在运行Shell的时候，自然是在user mode。
- 还有一堆控制CPU工作方式的寄存器，比如SATP（Supervisor Address Translation and Protection）寄存器，它包含了指向page table的物理内存地址（详见4.3）。
- 还有一些对于今天讨论非常重要的寄存器，比如STVEC（Supervisor Trap Vector Base Address Register）寄存器，它指向了内核中处理trap的指令的起始地址。
- SEPC（Supervisor Exception Program Counter）寄存器，在trap的过程中保存程序计数器的值。
- SSRATCH（Supervisor Scratch Register）寄存器，这也是个非常重要的寄存器（详见6.5）。

在trap的最开始，CPU的所有状态都设置成运行用户代码而不是内核代码。在trap处理的过程中，我们实际上需要更改一些这里的状态，或者对状态做一些操作。这样我们才可以运行系统内核中普通的C程序。接下来我们先来预览一下需要做的操作：

- 首先，我们需要保存32个用户寄存器。因为很显然我们需要恢复用户应用程序的执行，尤其是当用户程序随机的被设备中断所打断时。我们希望内核能够响应中断，之后在用户程序完全无感知的情况下再恢复用户代码的执行。所以这意味着32个用户寄存器不能被内核弄乱。但是这些寄存器又要被内核代码所使用，所以在trap之前，你必须先在某处保存这32个用户寄存器。
- 程序计数器也需要在某个地方保存，它几乎跟一个用户寄存器的地位是一样的，我们需要能够在用户程序运行中断的位置继续执行用户程序。
- 我们需要将mode改成supervisor mode，因为我们想要使用内核中的各种各样的特权指令。
- SATP寄存器现在正指向user page table，而user page table只包含了用户程序所需要的内存映射和一两个其他的映射，它并没有包含整个内核数据的内存映射。所以在运行内核代码之前，我们需要将SATP指向kernel page table。
- 我们需要将堆栈寄存器指向位于内核的一个地址，因为我们需要一个堆栈来调用内核的C函数。
- 一旦我们设置好了，并且所有的硬件状态都适合在内核中使用， 我们需要跳入内核的C代码。

操作系统的一些high-level的目标能帮我们过滤一些实现选项。其中一个目标是安全和隔离，我们不想让用户代码介入到这里的user/kernel切换，否则有可能会破坏安全性。所以这意味着，trap中涉及到的硬件和内核机制不能依赖任何来自用户空间东西。比如说我们不能依赖32个用户寄存器，它们可能保存的是恶意的数据，所以，XV6的trap机制不会查看这些寄存器，而只是将它们保存起来。

在supervisor mode时，你可以：读写SATP寄存器，也就是page table的指针；STVEC，也就是处理trap的内核指令地址；SEPC，保存当发生trap时的程序计数器；SSCRATCH等等。在supervisor mode你可以读写这些寄存器，而用户代码不能做这样的操作。

另一件事情supervisor mode可以做的是，它可以使用PTE_U标志位为0的PTE。当PTE_U标志位为1的时候，表明用户代码可以使用这个页表；如果这个标志位为0，则只有supervisor mode可以使用这个页表。我们接下来会看一下为什么这很重要。

用户程序通过执行ECALL指令来执行系统调用。ECALL指令会切换到具有supervisor mode的内核中。在这个过程中，内核中执行的第一个指令是一个由汇编语言写的函数，叫做uservec。这个函数是内核代码trampoline.s文件的一部分。所以执行的第一个代码就是这个uservec汇编函数。之后，在这个汇编函数中，代码执行跳转到了由C语言实现的函数usertrap中，这个函数在trap.c中。这个函数会在一个表单中，根据传入的代表系统调用的数字进行查找，并在内核中执行具体实现了系统调用功能的函数。

在ECALL之后，实际上会中断用户代码的执行，为了用户空间的代码恢复执行，需要做一系列事情。在syscall函数中，会调用一个函数叫做usertrapret，它也位于trap.c中，这个函数完成了部分方便在C代码中实现的返回到用户空间的工作。除此之外，最终还有一些工作只能在汇编语言中完成。这部分工作通过汇编语言实现，并且存在于trampoline.s文件中的userret函数中。最终，在这个汇编函数中会调用机器指令返回到用户空间，并且恢复ECALL之后的用户程序的执行。



# lab: traps
Alarm（困难）

在本练习中，你需要给 xv6 添加一个功能：周期性地提醒某个进程它正在消耗 CPU 时间。
这对一些计算密集型进程非常有用，它们可能希望限制自己的 CPU 使用量，或者在计算的同时执行一些周期性操作。更一般地说，你实际上是在实现一种用户级中断/异常处理机制；类似的机制可以用来在应用程序中处理页面错误等情况。

你的实现正确的标准是：通过 alarmtest 测试，并且 usertests -q 全部通过。

功能要求

你需要新增一个系统调用：
```
int sigalarm(int interval, void (*handler)());
```

如果应用程序调用 sigalarm(n, fn)，那么在该程序每消耗 n 个 CPU tick 后，内核应该调用用户函数 fn。

当 fn 返回后，应用程序应该从被中断的位k置继续执行。

xv6 中的一个 tick 是一个相对任意的时间单位，由硬件定时器中断决定。

如果应用程序调用 sigalarm(0, 0)，内核应该停止触发周期性 alarm。

在你的 xv6 仓库中可以找到 user/alarmtest.c。你需要在 Makefile 中添加它。


usertrap() 的作用

这是 从用户态陷入内核态 时的总入口（异常/中断处理），负责处理三类情况：

系统调用（ecall 指令触发）

设备中断（比如时钟中断、磁盘中断、uart 等）

其他异常（非法指令、缺页等）

最终它会跳回到用户态继续执行