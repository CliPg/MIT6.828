# lab: networking

## Background

你将使用一个名为 E1000 的网络设备来处理网络通信。对 xv6（以及你将编写的驱动程序）来说，E1000 看起来就像是一块真实存在的硬件网卡，连接在一个真实的以太网局域网（LAN）上。实际上，你的驱动所交互的 E1000 是由 qemu 模拟（emulate）出来的，它连接到一个 同样由 qemu 模拟的局域网。在这个模拟的局域网中，xv6（作为“客户机”）的 IP 地址是 10.0.2.15。同时，qemu 还会让运行它的主机计算机（即“宿主机”）在这个局域网中看起来拥有 IP 地址 10.0.2.2。当 xv6 使用 E1000 发送一个数据包到 10.0.2.2 时，qemu 会把该数据包转发给运行 qemu 的那台真实计算机上相应的应用程序（也就是“宿主机”上的程序）。

你将使用 QEMU 的“用户态网络栈（user-mode network stack）”。QEMU 的文档中对这个用户态网络栈有更详细的说明。我们已经在 Makefile 中进行了更新，以启用 QEMU 的用户态网络栈 和 E1000 网卡。Makefile 还配置了 QEMU，使其会将所有进出 xv6 的网络数据包记录到实验目录下的一个文件：packets.pcap查看这个文件有助于你确认 xv6 是否按预期发送和接收了数据包。你可以使用以下命令查看记录的数据包内容：
```
tcpdump -XXnr packets.pcap
```
（该命令会以十六进制和 ASCII 的形式显示每个数据包的详细内容。）

我们在本次实验中为 xv6 仓库添加了一些文件。文件 kernel/e1000.c 包含了 E1000 网卡的初始化代码，以及用于发送和接收数据包的空函数，这些函数需要由你来补全。文件 kernel/e1000_dev.h 定义了 E1000 的寄存器和标志位，这些定义来自 Intel E1000 软件开发者手册（Software Developer’s Manual）。文件 kernel/net.c 和 kernel/net.h 实现了一个简单的 网络协议栈（network stack），包括 IP、UDP 和 ARP 协议。
这两个文件还包含了一种用于存放网络数据包的灵活数据结构，称为 mbuf。最后，文件 kernel/pci.c 包含了 xv6 在启动时在 PCI 总线上查找 E1000 网卡的代码。

## Your Job

你的任务是完成 kernel/e1000.c 文件中的两个函数：
e1000_transmit() 和 e1000_recv()，
让驱动程序能够正确地发送和接收数据包。

当你运行 make grade 并且所有测试都通过时，就表示你已经完成了本次实验。

在编写代码的过程中，你需要参考 《E1000 软件开发者手册（E1000 Software Developer’s Manual）》。
以下几个章节会对你特别有帮助：
- 第 2 章：非常重要，它对整个设备进行了总体概述。
- 第 3.2 节：介绍了数据包接收机制的整体流程。
- 第 3.3 节（以及 第 3.4 节）：介绍了数据包发送机制的工作原理。
- 第 13 章：概述了 E1000 所使用的寄存器。
- 第 14 章：有助于你理解我们提供的 初始化代码（init code）。

请先浏览 《E1000 软件开发者手册（E1000 Software Developer’s Manual）》。
该手册涵盖了多个密切相关的以太网控制器，而 QEMU 模拟的是 82540EM 型号。

你现在可以先快速阅读第 2 章，以便对该设备有一个整体印象。
在编写驱动程序时，你需要重点熟悉以下章节：
- 第 3 章 和 第 14 章：这是你编写驱动所必需掌握的内容；
- 第 4.1 节（不包括其子章节）；
- 第 13 章：作为寄存器的主要参考资料。

其他章节主要介绍 E1000 的一些你无需接触的复杂功能，可以暂时忽略。
一开始不用深入研究细节，重点是先了解文档的结构，以便后续能快速查找需要的信息。
E1000 拥有许多高级功能，但为了完成本实验，你只需掌握其中的一小部分基本功能即可。

我们在 e1000.c 中提供的 e1000_init() 函数已经帮你完成了对 E1000 的配置，
使其能够从 RAM 中读取待发送的数据包，并把 接收到的数据包写入 RAM。
这种机制称为 DMA（直接内存访问，Direct Memory Access），
意思是 E1000 硬件可以直接从内存中读写数据包，而无需经过 CPU 的额外拷贝。

由于在某些情况下，数据包到达的速度可能快于驱动程序的处理速度，e1000_init() 会为 E1000 提供多个缓冲区（buffer），以便它能将接收到的数据包写入其中。

E1000 要求这些缓冲区由一组存放在 RAM 中的“描述符（descriptor）”数组 来描述；每个描述符中都包含一个内存地址，E1000 会将接收到的数据包写入该地址。描述符的具体格式由结构体 struct rx_desc 定义。

这组描述符数组称为 接收环（receive ring） 或 接收队列（receive queue）。它是一个循环队列（circular ring），也就是说，当网卡或驱动处理到数组末尾时，会自动回绕到数组的开头继续使用。

在初始化过程中，e1000_init() 会通过 mbufalloc() 分配若干 mbuf 数据包缓冲区，供 E1000 通过 DMA（直接内存访问） 将数据包写入。

此外，E1000 还有一个用于发送数据的环形队列，称为 发送环（transmit ring）。驱动程序需要将要发送的包放入这个环中。e1000_init() 会将接收环和发送环的大小分别设置为 RX_RING_SIZE 和 TX_RING_SIZE。

当 net.c 中的网络协议栈需要发送数据包时，它会调用 e1000_transmit()，并传入一个包含待发送数据的 mbuf。

你的发送函数需要将该数据包的指针填入 发送环（TX ring） 中的一个描述符中。描述符的格式由 struct tx_desc 定义。

你还必须确保每个 mbuf 在数据包被 E1000 完全发送之后 再释放。当 E1000 完成某个数据包的发送时，它会在对应描述符中设置标志位E1000_TXD_STAT_DD 来表示发送完成。

当 E1000 从以太网接收到一个数据包时，它会通过 DMA（直接内存访问） 将该数据包写入 接收环（RX ring） 中下一个描述符（descriptor）所指向的内存地址（即 addr 字段）。

如果此时 E1000 的中断尚未被触发，E1000 会请求 PLIC（Platform-Level Interrupt Controller） 在中断允许的情况下尽快发出中断。

你的 e1000_recv() 函数需要执行以下操作：
- 扫描整个 接收环（RX ring）；
- 对于每一个新接收到的数据包，将其对应的 mbuf 传递给网络协议栈（net.c）处理，具体做法是调用 net_rx() 函数；
- 然后你需要为该位置重新分配一个新的 mbuf，并把它放回描述符中，
这样当 E1000 再次循环到这个描述符时，就能在这里找到一个新的缓冲区用于 DMA 写入新的数据包。

除了在 RAM 中读写这些描述符环之外，
你的驱动程序还需要通过 E1000 的内存映射控制寄存器（memory-mapped control registers） 与设备交互：
- 检测是否有新的接收数据包可用；
- 通知 E1000 已经准备好了一些待发送的数据包（即填充了 TX 描述符）。

全局变量 regs 指向 E1000 控制寄存器的起始地址；
你的驱动可以通过将 regs 当作数组使用来访问其他寄存器。
你需要特别用到的两个寄存器索引是：
- E1000_RDT（接收环尾指针 Receive Descriptor Tail）；
- E1000_TDT（发送环尾指针 Transmit Descriptor Tail）。

测试方法：
1.	在一个终端窗口中运行：
```
make server
```
2.	在另一个窗口中运行：
```
make qemu
```
然后在 xv6 的 shell 中执行：
```
nettests
```
nettests 的第一个测试会尝试向宿主机（Host OS）发送一个 UDP 数据包，
目标地址是 make server 运行的服务程序。

如果你还没有完成本实验，E1000 驱动不会真正发送这个数据包，因此不会有任何反应。

但当你的驱动程序完成后：
- E1000 驱动会成功发送数据包；
- QEMU 会将它转发到宿主机；
- make server 会接收到数据包并返回响应；
- E1000 驱动随后会接收到这个响应包并交给 nettests；

在宿主机发送响应之前，它会先发送一个 ARP 请求包（Address Resolution Protocol） 给 xv6，以查询 xv6 的 48 位以太网（MAC）地址，xv6 需要返回一个 ARP 回复包（ARP reply）。当你完成 E1000 驱动后，kernel/net.c 会自动帮你处理 ARP 回复的细节。

如果一切工作正常，nettests 会输出：
```
testing ping: OK
```
而宿主机上的 make server 会打印出：
```
message from xv6!
```

## 提示：

首先，在 e1000_transmit() 和 e1000_recv() 函数中加入一些 调试输出语句（print 语句），
然后分别运行：
```
make server
```
以及在 xv6 中执行：
```
nettests
```
你会从打印信息中看到，nettests 确实调用了 e1000_transmit()。



### 实现 e1000_transmit() 的提示：
1.	获取当前发送环索引
从 E1000_TDT 控制寄存器 中读取当前 E1000 期望放入下一个待发送包的 发送环索引（TX ring index）。
2.	检查是否溢出（即环是否满）
查看当前描述符（由 E1000_TDT 索引）的状态位是否包含 E1000_TXD_STAT_DD。
如果没有设置，说明 E1000 还没有完成上一个发送请求，
这意味着发送环已满，此时应返回 -1（表示失败）。
3.	释放旧的 mbuf
如果该描述符中之前存放过一个 mbuf，并且它已被发送完毕，
使用 mbuffree() 释放它。
4.	填写描述符（descriptor）
- m->head 指向待发送数据包在内存中的起始位置。
- m->len 是该数据包的长度。
- 设置描述符中的必要命令标志位（cmd），
具体请参考 E1000 手册的 第 3.3 节（数据包发送部分）。
- 保存指向当前 mbuf 的指针，供稍后释放使用。
5.	更新环位置
将 E1000_TDT 加 1（取模 TX_RING_SIZE）更新环形队列的当前位置。
6.	返回结果
如果成功将 mbuf 添加到发送环中，返回 0；
若失败（例如发送队列已满），返回 -1，让调用者自行释放 mbuf。


### 实现 e1000_recv() 的提示：
1.	获取下一个可接收位置
从 E1000_RDT 控制寄存器中读取当前接收环尾索引，
并计算下一个索引：

(E1000_RDT + 1) % RX_RING_SIZE


2.	检查是否有新数据包可用
查看该接收描述符的状态字段中是否设置了 E1000_RXD_STAT_DD 标志。
如果没有，说明没有新的数据包可接收，直接返回。
3.	读取并上交数据包
- 将 mbuf->len 设置为描述符中报告的实际数据包长度。
- 调用 net_rx() 将此 mbuf 交给网络协议栈。
4.	分配新的接收缓冲区
- 使用 mbufalloc() 分配一个新的 mbuf。
- 将其 m->head 地址写入该描述符的 addr 字段，
以便下次 DMA 写入新的包。
- 清空描述符状态字段（status = 0）。
5.	更新 E1000_RDT 寄存器
将 E1000_RDT 更新为当前处理完的最后一个描述符的索引。


## 额外提示：
- e1000_init() 函数已经初始化了接收环（RX ring），
你可以查看其实现，借鉴它如何使用 mbufalloc() 来填充接收描述符。
- 随着时间推移，接收的数据包总数会超过接收环大小（默认 16），
因此你的代码必须能够正确处理 环形队列回绕（wrap-around）。
- 由于 xv6 可能会在多个进程中使用 E1000，
或者在内核线程处理中断时同时访问网卡，
你需要使用 锁（lock） 来保证线程安全。