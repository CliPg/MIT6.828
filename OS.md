操作系统通过一个接口向用户程序提供服务。设计一个良好的接口实际上是一件很难的事。一方面，我们希望接口简单而精炼，这样可以更容易地实现正确的功能；另一方面，我们又可能希望向应用程序提供许多复杂的特性。解决这种矛盾的技巧在于，设计依赖少量机制但能灵活组合的接口，从而提供极大的通用性。

内核具有直接访问硬件的特权，普通函数无法直接访问硬件，系统调用可以

文件描述符是某个文件在某个进程内的唯一编号



## 第一章 第一个进程

### 进程概览

进程向程序提供“看上去”私有的，其他进程无法读写的内存系统（或地址空间），以及一颗“看上去”仅执行该程序的CPU。

xv6 使用页表每个进程提供其独有的地址空间。页表将*虚拟地址*映射”为*物理地址*

每个进程有各自的页表，页表是一片地址空间，从虚拟地址0开始，包含用户内存和内核内存

![image-20250910125102424](imgs\f1.png)

当进程使用系统调用时，系统调用在进程地址空间的内核区域执行，这样可以使内核的系统调用代码可以直接指向用户内存。

xv6使用结构体struct proc维护进程状态，包括**页表**、**内核栈**、**当前运行状态**

每个进程都有一个运行线程（或简称为*线程*）来执行进程的指令。线程可以被暂时挂起，稍后再恢复运行。系统在进程之间切换实际上就是挂起当前运行的线程，恢复另一个进程的线程。线程的大多数状态（局部变量和函数调用的返回地址）都保存在线程的栈上。

每个进程都有用户栈和内核栈（`p->kstack`）。当进程运行用户指令时，只有其用户栈被使用，其内核栈则是空的。然而当进程（通过系统调用或中断）进入内核时，内核代码就在进程的内核栈中执行；进程处于内核中时，其用户栈仍然保存着数据，只是暂时处于不活跃状态。进程的线程交替地使用着用户栈和内核栈。要注意内核栈是用户代码无法使用的，这样即使一个进程破坏了自己的用户栈，内核也能保持运行。

### 代码：第一个地址空间

1. 

当电脑开机时，它会初始化自己，然后从磁盘中载入**boot loader**到内存并运行，然后boot loader把xv6内核从磁盘中载入并从**entry**开始运行。

**Boot Loader（引导加载程序）** 是计算机启动过程中的一段小型程序，负责把操作系统从存储设备加载到内存，并将控制权交给操作系统内核。它是硬件和操作系统之间的桥梁

boot loader 把 xv6 内核装载到物理地址 0x100000 处。之所以没有装载到内核指令和内核数据应该出现的 0x80100000，是因为小型机器上很可能没有这么大的物理内存。而之所以在 0x100000 而不是 0x0 则是因为地址 0xa0000 到 0x100000 是属于 I/O 设备的。

2. 

   然后将entrypgdir的物理地址载入到控制寄存器%cr3，entrypgdir用来翻译虚拟地址

3. 

   接着entry跳转到内核的C代码。首先将栈指针%esp指向被用作栈的一段内存，再跳转到main，初始化一些设备和子系统。

   

### 代码：创建第一个进程

1. 

   通过调用**userinit**建立第一个进程。userinit首先调用allocproc。allocproc的工作在页表中分配一个槽（struct proc），并初始化进程的状态，userinit只在创建第一个进程时会被调用，而allocproc创建每个进程时都会被调用。`allocproc` 会在 `proc` 的表中找到一个标记为 `UNUSED`(2211-2213)的槽位。当它找到这样一个未被使用的槽位后，`allocproc` 将其状态设置为 `EMBRYO`，使其被标记为被使用的并给这个进程一个独有的 `pid`（2201-2219）。接下来，它尝试为进程的内核线程分配内核栈。如果分配失败了，`allocproc` 会把这个槽位的状态恢复为 `UNUSED` 并返回0以标记失败。





### 运行第一个进程

在 `main` 调用了 `userinit` 之后， `mpmain` 调用 `scheduler` 开始运行进程


## 第二章 页表

操作系统通过页表机制实现了对内存空间的控制。页表使得 xv6 能够让**不同进程各自的地址空间映射到相同的物理内存**上，还能够为不同进程的内存提供保护。 一个进程对应一张页表


### 分页硬件
x86的指令计算的都是虚拟地址。机器的RAM或物理内存，则是用物理地址标记。

在xv6操作系统，一个字64位，虚拟地址有25位用不到，用3*9=27位表示三级页表，12位表示偏移地址。
一个页表包含2^9=512个页表项，一个页表项前44位表示物理页号（PPN），10位表示标志位。

分页硬件（物理地址）要找到一个虚拟地址对应的PTE，只需要使用其高44位来找到虚拟地址在页表的索引（PPN），然后把其高44位替换位对应PTE的PPN（物理地址和虚拟地址的前44为存在一个映射关系）。而低12位是会被分页硬件原样复制的。在这样的翻译机制下，页表可以位操作系统提供一块块大小为4096字节的内存片。

对于多级页表，高级页表的每个页表项指向下一级页表的起始地址（通过PPN映射）。多级页表可以节省内存，只为实际使用的虚拟页分配内存。

例如：

单级页表：

页表位数27位， 2^27 个页表项，每个页表项8字节，则需要1GB

无论进程实际使用多少虚拟内存，这1GB页表都必须分配。

多级页表：

页表L2只需要分配512个条目，共4KB

中间层L1和叶子L0页表按需分配，只有对应的虚拟页被访问，才分配L0页表，对应的L1条目才存在。

## 第六章 文件系统

文件系统是用来组织和存储数据的，要支持用户和程序间的数据共享，并提供数据持久化。

xv6的文件由文件描述符、目录、路径名构成，并把数据存储到IDE磁盘上。

文件系统必须设计好磁盘上的什么地方放置inode和数据块。xv6把磁盘划分为如下几个区块。

![f6-2](https://th0ar.gitbooks.io/xv6-chinese/content/pic/f6-2.png)

文件系统不使用第0块，它是用来启动操作系统的。第一块是超级块，包含了文件系统的元信息，包括文件系统的总块数，数据块块数，inode数，日志块数。第二块开始存放inode，每一块能存放多个inode。接下来的块存放空闲块位图。剩下大部分块是数据块，保存文件和目录的内容。最后是日志块。

xv6的文件系统分六层实现，如下图所示。

![f6-1](https://th0ar.gitbooks.io/xv6-chinese/content/pic/f6-1.png)

**最下面往上数，第一层是块缓冲层**，能起缓冲作用，同时还能保证同时只有一个内核进程可以修改磁盘块（guard)。这一层和数据库的buffer pool manager有点像。它用两个任务：其一是同步对磁盘的访问，每一块，同一时间只有一份拷贝放在内存，并且只有一个内核线程使用这份拷贝。其二是缓存作用。块缓冲仅允许最多一个内核线程引用它，以此来同步对磁盘的访问，如果一个内核线程引用了一个缓冲块，但还没有释放它，那么其他调用 `bread` 的进程就会阻塞。但实际上现代操作系统是可以允许多个线程只读一个缓冲块的。缓冲区数量有限，采用LRU替换策略。

块缓冲是通过双向链表实现的。一个缓冲区有三种状态：VALID意味着这个缓冲区拥有磁盘块的有效内容。DIRTY意味着缓冲区的内容已经被改变，需要写会磁盘。BUSY意味着内核线程持有这个缓冲区且未释放。



**第二层是日志层**，将对磁盘的更新按会话打包，通过会话的方式保证这些操作是原子操作，一个系统调用会把一个对磁盘写操作的描述包装成一个日志写在磁盘。当系统调用把所有写操作都写入日志，它会写一个特殊的提交记录到磁盘，代表一次完整的操作。写操作都成功完成后，系统调用会删除磁盘上的日志文件。通过这样的日志方式就可以解决文件系统操作的中出现的崩溃。因为如果崩溃发生在操作提交前，磁盘上的日志文件不会标记为完成，恢复系统的代码会忽视它。如果在操作提交后崩溃，写操作可能还没有完全写入磁盘，恢复程序会重演写操作。

日志的常见使用方法

```
begin_trans();//开启事务
...
bp = bread(...);
bp->data[...] = ...;
log_write(bp);
...
commit_trans();//提交事务
```



**第三层是文件层**，提供无名文件，每个文件由一个inode和一连串的数据块组成。inode可以指磁盘上的记录文件大小、数据块扇区号的数据结构。也可以指内存中的一个 i 节点，它包含了一个磁盘上 i 节点的拷贝，以及一些内核需要的附加信息。

磁盘上的 i 节点由结构体 `dinode`（3676）定义。`type` 域用来区分文件、目录和特殊文件的 i 节点。如果 `type` 是0的话就意味着这是一个空闲的 i 节点。`nlink` 域用来记录指向了这一个 i 节点的目录项，这是用于判断一个 i 节点是否应该被释放的。`size` 域记录了文件的字节数。`addrs` 数组用于这个文件的数据块的块号。

内核在内存中维护活动的 i 节点。结构体 `inode`（3762）是磁盘中的结构体 `dinode` 在内存中的拷贝。内核只会在有 C 指针指向一个 i 节点的时候才会把这个 i 节点保存在内存中。`ref` 域用于统计有多少个 C 指针指向它。如果 `ref` 变为0，内核就会丢掉这个 i 节点。`iget` 和 `iput` 两个函数申请和释放 i 节点指针，修改引用计数。i 节点指针可能从文件描述符产生，从当前工作目录产生，也有可能从一些内核代码如 `exec` 中产生。

要申请一个新的 i 节点（比如创建文件的时候），xv6 会调用 `ialloc`（4603）。`ialloc` 同 `balloc` 类似：它逐块遍历磁盘上的 i 节点数据结构，寻找一个标记为空闲的 i 节点。当它找到一个时，就会把它的 `type` 修改掉（变为非0），最后调用 `iget`（4620)使得它从 i 节点缓存中返回。由于每个时刻只有一个进程能访问 `bp`，`ialloc` 可以保证其他进程不会同时认为这个 i 节点是可用的并且获取到它。

`iget`（4654）遍历 i 节点缓存寻找一个指定设备和 i 节点号的活动中的项（`ip->ref > 0`)。如果它找到一项，它就返回对这个 i 节点的引用（4663-4667）。在 `iget` 扫描的时候，它会记录扫描到的第一个空槽（4668-4669），之后如果需要可以用这个空槽来分配一个新的缓存项。

调用者在读写 i 节点的元数据或内容之前必须用 `ilock`锁住 i 节点。`ilock`（4703）用一个类似的睡眠循环（这种循环在 `bget` 中见过）来等待 `ip->flag` 的 `I_BUSY` 位被清除，而后由自己再设置它（4712-4714）。一旦 `ilock` 拥有了对 i 节点的独占，他可以根据需要从磁盘中读取出 i 节点的元数据。函数 `iunlock`（4735）清除 `I_BUSY` 位并且唤醒睡眠在 `ilock` 中的其他进程。

`iput`（4756）释放指向 i 节点的 C 指针，实际上就是将引用计数减1。如果减到了0，那么 i 节点缓存中的这个 i 节点槽就会变为空闲状态，并且可以被另一个 i 节点重用。

如果 `iput` 发现没有指针指向一个 i 节点并且也没有任何目录项指向它（不在目录中出现的一个文件），那么这个 i 节点和它关联的数据块都应该被释放。`iput`重新锁上这个 i 节点，调用 `itrunc` 来把文件截断为0字节，释放掉数据块；把 i 节点的类型设置为0（未分配）；把变化写到磁盘中；最后解锁 i 节点（4759-4771）。

`iput` 中对锁的使用方法值得我们研究。第一个值得研究的地方是当锁上 `ip` 的时候， `put` 简单地认为它是没有被锁过的，而非使用一个睡眠循环。这种情况是正常的，因为调用者被要求在调用 `iput` 之前解锁 `ip` ，而调用者拥有对它的唯一引用（`ip->ref == 1`)。第二个值得研究的部分是 `iput` 临时释放后又重新获取了缓存的锁（4764）。这是必要的因为 `itrunc` 和 `iupdate` 可能会在磁盘 i/o 中睡眠，但是我们必须考虑在没有锁的这段时间都发生了什么。例如，一旦 `iupdate` 结束了，磁盘上的数据结构就被标注为可用的，而并发的一个 `ialloc` 的调用就可能找到它并且重新分配它，而这一切都在 `iput` 结束之前发生。`ialloc` 会通过调用 `iget` 返回对这一块的引用，而 `iget` 此时找到了 `ip`，但看见它的 `I_BUSY` 位是设置了的，从而睡眠。现在内存中的 i 节点就和磁盘上的不同步了：`ialloc` 重新初始化了磁盘上的版本，但需要其他的调用者通过 `ilock` 来将它调入内存，可是 `iget` 因为现在的 `ip` 的 `I_BUSY` 位被设置而进入了睡眠。为了保证这件事发生，`iput` 必须在释放锁之前把 `I_BUSY` 和 `I_VALID` 位都清除，所以它将 `flags` 清零（4769）。



**第四层是目录层**。每个目录是一连串的目录项，每个目录项包含一个文件名和对应的inode。

**第五层是文件描述符层**。通过递归来查询路径对应的文件。

第六层是系统调用层。将unix的资源抽象为文件系统的接口。