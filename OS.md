操作系统通过一个接口向用户程序提供服务。设计一个良好的接口实际上是一件很难的事。一方面，我们希望接口简单而精炼，这样可以更容易地实现正确的功能；另一方面，我们又可能希望向应用程序提供许多复杂的特性。解决这种矛盾的技巧在于，设计依赖少量机制但能灵活组合的接口，从而提供极大的通用性。

内核具有直接访问硬件的特权，普通函数无法直接访问硬件，系统调用可以

文件描述符是某个文件在某个进程内的唯一编号



## 第一章 第一个进程

### 进程概览

进程向程序提供“看上去”私有的，其他进程无法读写的内存系统（或地址空间），以及一颗“看上去”仅执行该程序的CPU。

xv6 使用页表每个进程提供其独有的地址空间。页表将*虚拟地址*映射”为*物理地址*

每个进程有各自的页表，页表是一片地址空间，从虚拟地址0开始，包含用户内存和内核内存

![image-20250910125102424](imgs\f1.png)

当进程使用系统调用时，系统调用在进程地址空间的内核区域执行，这样可以使内核的系统调用代码可以直接指向用户内存。

xv6使用结构体struct proc维护进程状态，包括**页表**、**内核栈**、**当前运行状态**

每个进程都有一个运行线程（或简称为*线程*）来执行进程的指令。线程可以被暂时挂起，稍后再恢复运行。系统在进程之间切换实际上就是挂起当前运行的线程，恢复另一个进程的线程。线程的大多数状态（局部变量和函数调用的返回地址）都保存在线程的栈上。

每个进程都有用户栈和内核栈（`p->kstack`）。当进程运行用户指令时，只有其用户栈被使用，其内核栈则是空的。然而当进程（通过系统调用或中断）进入内核时，内核代码就在进程的内核栈中执行；进程处于内核中时，其用户栈仍然保存着数据，只是暂时处于不活跃状态。进程的线程交替地使用着用户栈和内核栈。要注意内核栈是用户代码无法使用的，这样即使一个进程破坏了自己的用户栈，内核也能保持运行。

### 代码：第一个地址空间

1. 

当电脑开机时，它会初始化自己，然后从磁盘中载入**boot loader**到内存并运行，然后boot loader把xv6内核从磁盘中载入并从**entry**开始运行。

**Boot Loader（引导加载程序）** 是计算机启动过程中的一段小型程序，负责把操作系统从存储设备加载到内存，并将控制权交给操作系统内核。它是硬件和操作系统之间的桥梁

boot loader 把 xv6 内核装载到物理地址 0x100000 处。之所以没有装载到内核指令和内核数据应该出现的 0x80100000，是因为小型机器上很可能没有这么大的物理内存。而之所以在 0x100000 而不是 0x0 则是因为地址 0xa0000 到 0x100000 是属于 I/O 设备的。

2. 

   然后将entrypgdir的物理地址载入到控制寄存器%cr3，entrypgdir用来翻译虚拟地址

3. 

   接着entry跳转到内核的C代码。首先将栈指针%esp指向被用作栈的一段内存，再跳转到main，初始化一些设备和子系统。

   

### 代码：创建第一个进程

1. 

   通过调用**userinit**建立第一个进程。userinit首先调用allocproc。allocproc的工作在页表中分配一个槽（struct proc），并初始化进程的状态，userinit只在创建第一个进程时会被调用，而allocproc创建每个进程时都会被调用。`allocproc` 会在 `proc` 的表中找到一个标记为 `UNUSED`(2211-2213)的槽位。当它找到这样一个未被使用的槽位后，`allocproc` 将其状态设置为 `EMBRYO`，使其被标记为被使用的并给这个进程一个独有的 `pid`（2201-2219）。接下来，它尝试为进程的内核线程分配内核栈。如果分配失败了，`allocproc` 会把这个槽位的状态恢复为 `UNUSED` 并返回0以标记失败。





### 运行第一个进程

在 `main` 调用了 `userinit` 之后， `mpmain` 调用 `scheduler` 开始运行进程


## 第二章 页表

操作系统通过页表机制实现了对内存空间的控制。页表使得 xv6 能够让**不同进程各自的地址空间映射到相同的物理内存**上，还能够为不同进程的内存提供保护。 一个进程对应一张页表


### 分页硬件
x86的指令计算的都是虚拟地址。机器的RAM或物理内存，则是用物理地址标记。

在xv6操作系统，一个字64位，虚拟地址有25位用不到，用3*9=27位表示三级页表，12位表示偏移地址。
一个页表包含2^9=512个页表项，一个页表项前44位表示物理页号（PPN），10位表示标志位。

分页硬件（物理地址）要找到一个虚拟地址对应的PTE，只需要使用其高44位来找到虚拟地址在页表的索引（PPN），然后把其高44位替换位对应PTE的PPN（物理地址和虚拟地址的前44为存在一个映射关系）。而低12位是会被分页硬件原样复制的。在这样的翻译机制下，页表可以位操作系统提供一块块大小为4096字节的内存片。

对于多级页表，高级页表的每个页表项指向下一级页表的起始地址（通过PPN映射）。多级页表可以节省内存，只为实际使用的虚拟页分配内存。

例如：

单级页表：

页表位数27位， 2^27 个页表项，每个页表项8字节，则需要1GB

无论进程实际使用多少虚拟内存，这1GB页表都必须分配。

多级页表：

页表L2只需要分配512个条目，共4KB

中间层L1和叶子L0页表按需分配，只有对应的虚拟页被访问，才分配L0页表，对应的L1条目才存在。